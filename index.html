<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Pythagorean Theorem Visualiser</title>
		<script src="https://cdn.tailwindcss.com"></script>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
			rel="stylesheet"
		/>
		<link
			rel="icon"
			type="image/png"
			href="https://pbs.twimg.com/profile_images/1934315850149908480/jIjeWYOq_400x400.jpg"
		/>
		<style>
			body {
				font-family: "Inter", sans-serif;
				overscroll-behavior-y: contain;
			}
			canvas {
				touch-action: none;
			}
			/* Simple toggle switch styling */
			.toggle-checkbox:checked {
				right: 0;
				border-color: #4f46e5;
			}
			.toggle-checkbox:checked + .toggle-label {
				background-color: #4f46e5;
			}
		</style>
	</head>
	<body class="flex flex-col h-screen bg-gray-50 text-gray-800 antialiased">
		<header class="bg-white shadow-md p-4 z-10">
			<div class="max-w-7xl mx-auto text-center">
				<h1 class="text-2xl md:text-3xl font-bold text-gray-900">
					Interactive Pythagorean Theorem Visualizer
				</h1>
				<p class="text-sm md:text-md text-blue-600">
					A tool for GCSE & A-Level Students
				</p>
			</div>
		</header>
		<main
			class="flex-grow flex flex-col lg:flex-row items-center justify-center p-4 md:p-8 space-y-4 lg:space-y-0 lg:space-x-8 overflow-hidden"
		>
			<div
				class="w-full lg:w-2/3 h-2/5 lg:h-full max-w-3xl bg-white rounded-2xl shadow-lg border border-gray-200 cursor-grab active:cursor-grabbing"
			>
				<canvas id="visualizerCanvas"></canvas>
			</div>

			<div
				class="w-full lg:w-1/3 h-3/5 lg:h-auto max-w-md p-6 bg-white rounded-2xl shadow-lg border border-gray-200 overflow-y-auto"
			>
				<h2 class="text-xl font-semibold mb-2 text-center">
					Adjust & Explore
				</h2>
				<p class="text-center text-gray-500 mb-4">
					Drag to pan, scroll or pinch to zoom.
				</p>

				<div class="mb-6">
					<label
						for="sliderA"
						class="flex justify-between items-center text-lg font-medium text-red-600"
					>
						<span>Side a</span>
						<span
							id="valueA"
							class="px-3 py-1 bg-red-100 text-red-700 rounded-full text-base font-semibold"
							>30</span
						>
					</label>
					<input
						id="sliderA"
						type="range"
						min="1"
						max="100"
						value="30"
						class="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer"
					/>
				</div>

				<div class="mb-6">
					<label
						for="sliderB"
						class="flex justify-between items-center text-lg font-medium text-green-600"
					>
						<span>Side b</span>
						<span
							id="valueB"
							class="px-3 py-1 bg-green-100 text-green-700 rounded-full text-base font-semibold"
							>40</span
						>
					</label>
					<input
						id="sliderB"
						type="range"
						min="1"
						max="100"
						value="40"
						class="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer"
					/>
				</div>

				<!-- Toggle Switch for Squares -->
				<div class="flex items-center justify-between mt-6">
					<label
						for="showSquaresToggle"
						class="text-lg font-medium text-gray-700"
						>Show Squares</label
					>
					<div
						class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in"
					>
						<input
							type="checkbox"
							name="toggle"
							id="showSquaresToggle"
							class="toggle-checkbox absolute block w-7 h-7 rounded-full bg-white border-4 appearance-none cursor-pointer"
							checked
						/>
						<label
							for="showSquaresToggle"
							class="toggle-label block overflow-hidden h-7 rounded-full bg-gray-300 cursor-pointer"
						></label>
					</div>
				</div>

				<div class="mt-8 text-center">
					<button
						id="visualizeBtn"
						class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all duration-200 ease-in-out disabled:bg-gray-400 disabled:cursor-not-allowed"
					>
						Show Area Proof
					</button>
				</div>

				<div
					class="text-center bg-blue-50 border-l-4 border-blue-500 p-4 rounded-r-lg mt-8"
				>
					<h3 class="text-lg font-semibold text-gray-800 mb-2">
						The Theorem in Action
					</h3>
					<div
						class="text-xl md:text-2xl font-mono bg-white p-3 rounded-lg shadow-inner"
					>
						<span class="text-red-600">a²</span> +
						<span class="text-green-600">b²</span> =
						<span class="text-blue-600">c²</span>
					</div>
					<div
						id="formulaValues"
						class="text-md md:text-lg font-mono mt-3 text-gray-600 break-words"
					></div>
					<div
						id="formulaResult"
						class="text-md md:text-lg font-mono mt-2 text-gray-600 break-words"
					></div>
				</div>
			</div>
		</main>
		<footer
			class="bg-white text-center text-sm text-gray-500 p-4 border-t border-gray-200"
		>
			<p>
				&copy; <span id="year"></span> | A project by
				<a
					href="https://twitter.com/alvlmathteacher"
					target="_blank"
					rel="noopener noreferrer"
					class="text-indigo-600 hover:underline"
					>alvlmathteacher</a
				>
			</p>
		</footer>

		<script>
			document.addEventListener("DOMContentLoaded", () => {
				const canvas = document.getElementById("visualizerCanvas");
				const ctx = canvas.getContext("2d");
				const sliderA = document.getElementById("sliderA");
				const sliderB = document.getElementById("sliderB");
				const valueA = document.getElementById("valueA");
				const valueB = document.getElementById("valueB");
				const showSquaresToggle =
					document.getElementById("showSquaresToggle");
				const visualizeBtn = document.getElementById("visualizeBtn");
				const formulaValues = document.getElementById("formulaValues");
				const formulaResult = document.getElementById("formulaResult");

				// --- State ---
				let a = +sliderA.value;
				let b = +sliderB.value;
				let showSquares = showSquaresToggle.checked;
				let isAnimating = false;
				let animationStartTime = 0;
				const animationDuration = 2000;

				// --- Transformation State ---
				let scale = 2.5;
				let offsetX = 0;
				let offsetY = 0;
				let isDragging = false;
				let lastX = 0;
				let lastY = 0;
				let initialPinchDistance = null;
				let lastScale = 1;

				// --- Utility Functions ---
				// Linear interpolation function for smooth animation
				const lerp = (start, end, t) => start * (1 - t) + end * t;

				function resizeCanvas() {
					const parent = canvas.parentElement;
					canvas.width = parent.clientWidth * window.devicePixelRatio;
					canvas.height =
						parent.clientHeight * window.devicePixelRatio;
					canvas.style.width = `${parent.clientWidth}px`;
					canvas.style.height = `${parent.clientHeight}px`;
					if (!offsetX && !offsetY) {
						offsetX = canvas.width / 2;
						offsetY = canvas.height * 0.75;
					}
					draw();
				}

				// --- Main Drawing Logic ---
				function draw() {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					ctx.save();
					ctx.translate(offsetX, offsetY);
					ctx.scale(scale, scale);

					const c = Math.sqrt(a * a + b * b);
					const angle = Math.atan2(-a, b);

					if (showSquares) {
						// Draw the three squares if toggled on
						ctx.lineWidth = 2 / scale;
						ctx.fillStyle = "rgba(16, 185, 129, 0.6)";
						ctx.strokeStyle = "rgb(5, 150, 105)";
						ctx.fillRect(-b, 0, b, b);
						ctx.strokeRect(-b, 0, b, b);

						ctx.fillStyle = "rgba(239, 68, 68, 0.6)";
						ctx.strokeStyle = "rgb(220, 38, 38)";
						ctx.fillRect(0, -a, a, a);
						ctx.strokeRect(0, -a, a, a);

						ctx.save();
						ctx.translate(-b, 0);
						ctx.rotate(angle);
						ctx.fillStyle = "rgba(59, 130, 246, 0.6)";
						ctx.strokeStyle = "rgb(37, 99, 235)";
						ctx.fillRect(0, -c, c, c);
						ctx.strokeRect(0, -c, c, c);
						ctx.restore();
					}

					// Draw the main triangle background
					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(-b, 0);
					ctx.lineTo(0, -a);
					ctx.closePath();
					ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
					ctx.fill();

					// Draw colored edges for the triangle
					ctx.lineWidth = Math.max(1.5, Math.min(5, c / 40)) / scale;
					// Side b (green)
					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(-b, 0);
					ctx.strokeStyle = "rgb(5, 150, 105)";
					ctx.stroke();
					// Side a (red)
					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(0, -a);
					ctx.strokeStyle = "rgb(220, 38, 38)";
					ctx.stroke();
					// Side c (blue)
					ctx.beginPath();
					ctx.moveTo(-b, 0);
					ctx.lineTo(0, -a);
					ctx.strokeStyle = "rgb(37, 99, 235)";
					ctx.stroke();

					// Draw the numerical side length labels
					ctx.font = `bold ${60 / scale}px sans-serif`;
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";

					// Label 'a' (red)
					ctx.save();
					ctx.translate(30 / scale, -a / 2);
					ctx.rotate(Math.PI / 2);
					ctx.fillStyle = "rgb(220, 38, 38)";
					ctx.fillText(
						a % 1 === 0 ? a.toFixed(0) : a.toFixed(1),
						0,
						0
					);
					ctx.restore();

					// Label 'b' (green)
					ctx.fillStyle = "rgb(5, 150, 105)";
					ctx.fillText(
						b % 1 === 0 ? b.toFixed(0) : b.toFixed(1),
						-b / 2,
						30 / scale
					);

					// Label 'c' (blue)
					ctx.save();
					ctx.translate(-b / 2, -a / 2);
					ctx.rotate(angle);
					ctx.fillStyle = "rgb(37, 99, 235)";
					ctx.fillText(
						c % 1 === 0 ? c.toFixed(0) : c.toFixed(1),
						0,
						-30 / scale
					);
					ctx.restore();

					ctx.restore();
				}

				// --- Dissection Animation Logic ---
				function getDissectionPieces() {
					const c = Math.sqrt(a * a + b * b);
					const cos = b / c;
					const sin = a / c;

					// Center of square b
					const centerBx = -b / 2;
					const centerBy = b / 2;

					// Points for cutting square b
					const p1 = { x: -b, y: a * cos * cos };
					const p2 = { x: -b * sin * sin, y: 0 };
					const p3 = { x: -a * sin * cos, y: b };
					const p4 = { x: -b, y: b - a * cos * cos };

					const startPieces = {
						// Square a is the center piece
						centerPiece: [
							{ x: 0, y: 0 },
							{ x: a, y: 0 },
							{ x: a, y: -a },
							{ x: 0, y: -a },
						],
						// The four pieces from square b
						q1: [
							{ x: -b, y: 0 },
							p2,
							{ x: centerBx, y: centerBy },
							p1,
						],
						q2: [
							p2,
							{ x: 0, y: 0 },
							p3,
							{ x: centerBx, y: centerBy },
						],
						q3: [
							p3,
							{ x: 0, y: b },
							p4,
							{ x: centerBx, y: centerBy },
						],
						q4: [
							p4,
							{ x: -b, y: b },
							p1,
							{ x: centerBx, y: centerBy },
						],
					};

					const endPieces = {
						centerPiece: [
							{ x: a * sin, y: -a * cos },
							{ x: a * sin + a * cos, y: -a * cos + a * sin },
							{ x: a * cos, y: a * sin },
							{ x: 0, y: 0 },
						].map((p) => ({ x: p.x - b, y: p.y })),
						q1: [
							{ x: -b, y: 0 },
							{ x: 0, y: 0 },
							{ x: a * sin, y: -a * cos },
							{ x: a * sin - b, y: -a * cos },
						],
						q2: [
							{ x: 0, y: 0 },
							{ x: a * cos, y: a * sin },
							{ x: a * cos - b, y: a * sin },
							{ x: -b, y: 0 },
						],
						q3: [
							{ x: a * cos, y: a * sin },
							{ x: a * cos + a * sin, y: a * sin - a * cos },
							{ x: a * sin, y: -a * cos },
							{ x: 0, y: 0 },
						].map((p) => ({ x: p.x - b, y: p.y + b })),
						q4: [
							{ x: a * sin - b, y: -a * cos + b },
							{ x: a * sin, y: -a * cos },
							{ x: a * sin + a * cos, y: -a * cos + a * sin },
							{ x: a * cos, y: a * sin },
						].map((p) => ({ x: p.x - b, y: p.y - b })),
					};

					return { start: startPieces, end: endPieces };
				}

				function runAnimation(timestamp) {
					if (!animationStartTime) animationStartTime = timestamp;
					const progress = Math.min(
						(timestamp - animationStartTime) / animationDuration,
						1
					);
					const easedProgress =
						0.5 - 0.5 * Math.cos(progress * Math.PI); // Ease in-out

					draw();

					ctx.save();
					ctx.translate(offsetX, offsetY);
					ctx.scale(scale, scale);

					const pieces = getDissectionPieces();

					const drawPiece = (start, end, color) => {
						ctx.beginPath();
						const firstPoint = {
							x: lerp(start[0].x, end[0].x, easedProgress),
							y: lerp(start[0].y, end[0].y, easedProgress),
						};
						ctx.moveTo(firstPoint.x, firstPoint.y);
						for (let i = 1; i < start.length; i++) {
							const point = {
								x: lerp(start[i].x, end[i].x, easedProgress),
								y: lerp(start[i].y, end[i].y, easedProgress),
							};
							ctx.lineTo(point.x, point.y);
						}
						ctx.closePath();
						ctx.fillStyle = color;
						ctx.fill();
						ctx.stroke();
					};

					ctx.strokeStyle = "#1f2937";
					ctx.lineWidth = 1 / scale;

					drawPiece(
						pieces.start.centerPiece,
						pieces.end.centerPiece,
						"rgba(239, 68, 68, 0.8)"
					);
					drawPiece(
						pieces.start.q1,
						pieces.end.q1,
						"rgba(16, 185, 129, 0.8)"
					);
					drawPiece(
						pieces.start.q2,
						pieces.end.q2,
						"rgba(16, 185, 129, 0.8)"
					);
					drawPiece(
						pieces.start.q3,
						pieces.end.q3,
						"rgba(16, 185, 129, 0.8)"
					);
					drawPiece(
						pieces.start.q4,
						pieces.end.q4,
						"rgba(16, 185, 129, 0.8)"
					);

					ctx.restore();

					if (progress < 1) {
						requestAnimationFrame(runAnimation);
					} else {
						isAnimating = false;
						animationStartTime = 0;
						toggleControls();
						draw();
					}
				}

				function toggleControls() {
					sliderA.disabled = isAnimating;
					sliderB.disabled = isAnimating;
					visualizeBtn.disabled = isAnimating;
					visualizeBtn.textContent = isAnimating
						? "Animating..."
						: "Show Area Proof";
				}

				function updateUI() {
					a = +sliderA.value;
					b = +sliderB.value;
					valueA.textContent = a;
					valueB.textContent = b;
					const c = Math.sqrt(a * a + b * b);
					const aSq = a * a;
					const bSq = b * b;
					const cSq = Math.round(c * c);
					formulaValues.innerHTML = `<span class="text-red-600">${a}²</span> + <span class="text-green-600">${b}²</span> = <span class="text-blue-600">${c.toFixed(
						2
					)}²</span>`;
					formulaResult.innerHTML = `<span class="text-red-600">${aSq}</span> + <span class="text-green-600">${bSq}</span> = <span class="text-blue-600">${cSq}</span>`;
					draw();
				}

				function handlePan(dx, dy) {
					offsetX += dx;
					offsetY += dy;
					draw();
				}

				function handleZoom(delta, centerX, centerY) {
					const scaleAmount = 1.1;
					const worldX =
						(centerX * window.devicePixelRatio - offsetX) / scale;
					const worldY =
						(centerY * window.devicePixelRatio - offsetY) / scale;
					scale *= delta < 0 ? scaleAmount : 1 / scaleAmount;
					offsetX =
						centerX * window.devicePixelRatio - worldX * scale;
					offsetY =
						centerY * window.devicePixelRatio - worldY * scale;
					draw();
				}

				// --- Event Listeners ---
				sliderA.addEventListener("input", updateUI);
				sliderB.addEventListener("input", updateUI);
				showSquaresToggle.addEventListener("change", () => {
					showSquares = showSquaresToggle.checked;
					draw();
				});
				visualizeBtn.addEventListener("click", () => {
					if (!isAnimating) {
						isAnimating = true;
						toggleControls();
						if (!showSquares) {
							// Ensure squares are visible for animation
							showSquares = true;
							showSquaresToggle.checked = true;
						}
						requestAnimationFrame(runAnimation);
					}
				});
				canvas.addEventListener("mousedown", (e) => {
					isDragging = true;
					lastX = e.clientX;
					lastY = e.clientY;
				});
				canvas.addEventListener("mouseup", () => (isDragging = false));
				canvas.addEventListener(
					"mouseleave",
					() => (isDragging = false)
				);
				canvas.addEventListener("mousemove", (e) => {
					if (isDragging) {
						handlePan(e.clientX - lastX, e.clientY - lastY);
						lastX = e.clientX;
						lastY = e.clientY;
					}
				});
				canvas.addEventListener(
					"wheel",
					(e) => {
						e.preventDefault();
						const rect = canvas.getBoundingClientRect();
						handleZoom(
							e.deltaY,
							e.clientX - rect.left,
							e.clientY - rect.top
						);
					},
					{ passive: false }
				);
				canvas.addEventListener("touchstart", (e) => {
					if (e.touches.length === 1) {
						isDragging = true;
						lastX = e.touches[0].clientX;
						lastY = e.touches[0].clientY;
					} else if (e.touches.length === 2) {
						isDragging = false;
						initialPinchDistance = Math.hypot(
							e.touches[0].clientX - e.touches[1].clientX,
							e.touches[0].clientY - e.touches[1].clientY
						);
						lastScale = scale;
					}
				});
				canvas.addEventListener("touchend", () => {
					isDragging = false;
					initialPinchDistance = null;
				});
				canvas.addEventListener(
					"touchmove",
					(e) => {
						e.preventDefault();
						if (isDragging && e.touches.length === 1) {
							handlePan(
								e.touches[0].clientX - lastX,
								e.touches[0].clientY - lastY
							);
							lastX = e.touches[0].clientX;
							lastY = e.touches[0].clientY;
						} else if (
							initialPinchDistance &&
							e.touches.length === 2
						) {
							const newPinchDistance = Math.hypot(
								e.touches[0].clientX - e.touches[1].clientX,
								e.touches[0].clientY - e.touches[1].clientY
							);
							const scaleFactor =
								newPinchDistance / initialPinchDistance;
							const newScale = lastScale * scaleFactor;
							const rect = canvas.getBoundingClientRect();
							const midX =
								(e.touches[0].clientX + e.touches[1].clientX) /
									2 -
								rect.left;
							const midY =
								(e.touches[0].clientY + e.touches[1].clientY) /
									2 -
								rect.top;
							const oldScale = scale;
							scale = newScale;
							offsetX -=
								midX *
								window.devicePixelRatio *
								(1 / oldScale - 1 / newScale) *
								oldScale;
							offsetY -=
								midY *
								window.devicePixelRatio *
								(1 / oldScale - 1 / newScale) *
								oldScale;
							draw();
						}
					},
					{ passive: false }
				);
				window.addEventListener("resize", resizeCanvas);
				resizeCanvas();
				updateUI();
			});
		</script>
	</body>
</html>
